
# 描述

## 工厂方法模式：

    定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟加载到其子类
    
    引自GOF所著《Design Patterns》
    
    工厂方法模式的结构中包含四种角色
    1.产品（Product）：抽象类或者接口，定义了具体产品需要实现的方法
    2.具体产品（ConcreteProduct）： 具体产品是产品接口的实现类
    3.构造者(Creator): 构造者（也就是我们所谓的工厂）是一个接口，定义了遍历具体集合的方法
    4.具体迭代器（ConcreteCreator）：迭代器接口的具体实现

### 使用场景：
    得到一个类的子类的实例最常用的方法就是使用new关键字和该子类的构造方法，但是在某些情况下，用户可能不应该或者无法使用这种办法来得到一
    个子类的实例。其原因是系统不允许用户代码和该类的子类形成耦合或者用户不知道该类有哪些子类可用。比如，有一个汽车类Car,该类是一个抽象
    类或者接口，其有3个子类，BydCar(比亚迪汽车)、BsjCar(保时捷汽车)、BmCar(宝马汽车)，而我们系统设计的时候，同通过一个统一的入口来
    得到我们具体的汽车，当我们想要增加汽车种类的时候，不需要去修改原有的客户端代码
    
    需要说明的是，工厂方法一般会有很几种，比如简单工厂，静态工厂，工厂方法，抽象工厂等，需要在实现项目中灵活运用，我这里只举例了工厂方法
    这种模式，大家有兴趣可以自行去网上查找其他的工厂方式，但是思路都是差不多的。
    
    简单工厂：不能算是真正意义上的设计模式，但可以将客户程序从具体类解耦。
    
    静态工厂：静态工厂是部调用者只需要拿到一个实例，而不关心是否是新的实例
    
    工厂方法：使用继承，把对象的创建委托给子类，由子类来实现创建方法，可以看作是抽象工厂模式中只有单一产品的情况。
    
    抽象工厂：使对象的创建被实现在工厂接口所暴露出来的方法中。
    
    工厂模式可以帮助我们针对抽象/接口编程，而不是针对具体类编程，在不同的场景下按具体情况来使用
    
    下面，我们就以刚才说的汽车为例进行阐述说明。